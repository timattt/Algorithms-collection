# Безудержные-алгоритмы
Вот несколько полезных алгоритмов, реализованных на Java.

Теорминимум можно найти [здесь](http://e-maxx.ru/algo/)

## English version
You can find the English version of the readme [here](https://github.com/timattt/Rampant-algorithms/blob/master/README_EN.md)

## Алгоритмы
### Динамика
* Найти самую большую нулевую подматрицу
Вам дана матрица размера n на m.
Требуется найти в ней такую ​​подматрицу, состоящую только из нулей, и среди всего такого -
имеющий самую большую площадь.
### НОД
* Нормальный НОД
Вам даны два неотрицательных целых числа a и b. Требуется найти их наибольший общий делитель.
* Расширенный НОД
В то время как «нормальный» алгоритм Евклида просто находит наибольший общий делитель двух чисел a и b,
расширенный алгоритм Евклида находит, помимо НОД, такие коэффициенты x и y, что:
```
a * x + b * y = gcd (a, b);
```
### Графы
* Нахождение пути Эйлера
Путь Эйлера - это путь в графе, который проходит через все его ребра. Цикл Эйлера - это путь Эйлера, который является циклом.
Цель состоит в том, чтобы найти путь Эйлера в неориентированном мультиграфе с петлями.
* Проверка графа на ацикличность и поиск цикла
Пусть задан ориентированный или неориентированный граф без петель и кратных ребер.
Требуется проверить, ацикличен ли он, а если нет, то найти какой-нибудь цикл.
* Алгоритм Дейкстры
Вам дан ориентированный или неориентированный взвешенный граф с n вершинами и m ребрами.
Веса всех ребер неотрицательны. Указывается некоторая начальная вершина s.
Требуется найти длины кратчайших путей от вершины s до всех остальных вершин,
а также предоставить способ самому вывести кратчайшие пути.
* Поиск компонентов сильной связи
Компонента сильной связности в ориентированном графе - это (максимальная по включению)
подмножество вершин такое, что любые две вершины этого подмножества достижимы друг от друга
Описанный ниже алгоритм выбирает все сильно связанные компоненты в данном графе.
Построить из них конденсационный граф не составит труда.
* Топологическая сортировка
Вам дан ориентированный граф с n вершинами и m ребрами.
Требуется перенумеровать его вершины таким образом, чтобы каждое ребро выходило из
вершина с меньшим номером к вершине с большим.
* Посик остовного дерева по алгоритму Прима   
Вам дан взвешенный неориентированный граф G с n вершинами и m ребрами.
Требуется найти поддерево этого графа, которое бы соединяло все его вершины,
и при этом иметь минимально возможный вес.
* Поиск точек сочленения.
Пусть дан связный неориентированный граф.
Точка сочленения - это вершина, удаление которой делает граф несвязным.
* Найдите мосты
Пусть дан неориентированный граф.
Мост - это ребро, удаление которого делает граф несвязным.
(точнее, увеличивает количество связанных компонент). Найдите все мосты в заданном графе.
* Посик остовного дерева по алгоритму Крускалла
Дан взвешенный неориентированный граф.
Требуется найти поддерево этого графа, которое бы соединяло все его вершины,
и в то же время иметь наименьший вес (т.е. сумму весов ребер) из всех возможных.
* DFS
Это один из основных алгоритмов графа.
В результате поиска в глубину найден лексикографически первый путь в графе.
* BFS
Поиск в ширину - один из основных алгоритмов построения графов.
Поиск в ширину находит кратчайший путь в невзвешенном графе, то есть путь, содержащий наименьшее количество ребер.
* LCA
Пусть дано дерево G. На вход поступают запросы вида (V1, V2),
для каждого запроса требуется найти их наименее общего предка, т.е.
вершина V, лежащая на пути от корня до V1, на пути от
корень к V2, и из всех таких вершин следует выбрать самую низкую.
### Архививрование по Хафману
Алгоритм Хаффмана - это алгоритм оптимального префиксного кодирования алфавита с минимальной избыточностью.
### Поиск
* Бинарный поиск
Бинарный поиск - классический алгоритм поиска
элемент в отсортированном массиве, используя разделение массива пополам.
* Тернарный поиск
Пусть дана функция f (x), унимодальная на некотором отрезке [l; р].
Унимодальность относится к одному из двух вариантов. Во-первых: функция сначала строго возрастает,
затем достигает максимума (в одной точке или на всем отрезке), затем строго убывает.
Второй вариант, симметричный: функция сначала убывает, убывает, достигает минимума,
и увеличивается. В дальнейшем рассмотрим первый вариант, второй будет абсолютно
симметрично ему.
Требуется найти максимум функции f (x) на отрезке [l; р].
### Правило Симпсона
Требуется вычислить значение определенного интеграла.
### Z-функция
Пусть дана строка s длины n.
Тогда Z-функция этой строки представляет собой массив длины n, i-й элемент которого равен
до наибольшего количества символов, начиная с позиции i,
которые соответствуют первым символам строки s.
### Систему непересекающихся множеств
Эта структура данных предоставляет следующие возможности.
Изначально есть несколько элементов, каждый из которых находится в отдельном (своем) наборе.
За одну операцию можно расчесать
